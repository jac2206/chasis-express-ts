# üß± Express TS Chasis  
## DDD + Arquitectura Hexagonal + Awilix + Vitest

Backend base construido con:

- Node.js
- Express
- TypeScript
- DDD (Domain-Driven Design)
- Arquitectura Hexagonal (Ports & Adapters)
- Awilix (Inyecci√≥n de dependencias)
- Vitest (Testing + Coverage)

---

# üß† 1. Arquitectura

Este proyecto implementa:

- üîπ DDD (Domain-Driven Design)
- üîπ Arquitectura Hexagonal (Ports & Adapters)

---

## üî∑ ¬øQu√© significa Arquitectura Hexagonal?

El dominio est√° en el centro y define contratos (interfaces).
La infraestructura implementa esos contratos.

```
        HTTP (Express)
              ‚Üì
         Controller
              ‚Üì
          Use Case
              ‚Üì
           Domain
              ‚Üë
 Repository / Service / Adapter
```

### üìå Regla principal

> Las dependencias siempre apuntan hacia el dominio.

---

# üß± 2. Capas del Proyecto

---

## 2.1 Domain (Centro del sistema)

Contiene:

- Entidades
- Reglas de negocio
- Interfaces (Ports)

‚ùå No conoce Express  
‚ùå No conoce base de datos  
‚ùå No conoce frameworks  

### Ejemplo de Entity

```ts
export class Generic {
  constructor(
    private readonly name: string,
    private readonly lastName: string,
    private readonly age: number
  ) {
    if (age < 0) {
      throw new Error("Age cannot be negative");
    }
  }

  toPersistence() {
    return {
      name: this.name,
      lastName: this.lastName,
      age: this.age
    };
  }
}
```

### üîé ¬øQu√© es `toPersistence()`?

Es un m√©todo de la entidad que:

- Convierte la entidad a datos planos
- Se usa para persistencia (base de datos)
- No expone l√≥gica
- No conoce HTTP

---

## 2.2 Application

Contiene:

- Casos de uso
- DTOs

El Use Case ejecuta una acci√≥n del negocio.

### Ejemplo de Interface

```ts
export interface IGetGenericUseCase {
  execute(): Promise<Generic>;
}
```

---

### Ejemplo con m√∫ltiples dependencias

Un Use Case puede depender de:

- Repository
- Event Publisher
- Servicio externo
- Email Service
- API externa

```ts
export class CreateGenericUseCase {
  constructor(
    private readonly repository: GenericRepository,
    private readonly eventPublisher: EventPublisher
  ) {}

  async execute(input: CreateGenericDto): Promise<Generic> {
    const entity = new Generic(
      input.name,
      input.lastName,
      input.age
    );

    await this.repository.save(entity);
    await this.eventPublisher.publish("GenericCreated", entity);

    return entity;
  }
}
```

‚ö†Ô∏è El Use Case depende de interfaces, no de implementaciones.

---

## 2.3 Infrastructure

Contiene:

- Controllers
- Rutas HTTP
- Adaptadores
- Implementaciones concretas

### Ejemplo de Controller

```ts
export class GenericController {
  constructor(
    private readonly getGenericUseCase: IGetGenericUseCase
  ) {}

  getGeneric = async (_req: any, res: any) => {
    const result = await this.getGenericUseCase.execute();
    res.status(200).json(result.toPersistence());
  };
}
```

---

### Ejemplo de Route

```ts
router.get("/", (req, res) => {
  const controller = req.container.resolve("genericController");
  controller.getGeneric(req, res);
});
```

---

# üìÇ 3. Estructura del Proyecto

```
src
‚îú‚îÄ‚îÄ application
‚îÇ   ‚îú‚îÄ‚îÄ dto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ get-generic.dto.ts
‚îÇ   ‚îî‚îÄ‚îÄ use-cases
‚îÇ       ‚îî‚îÄ‚îÄ generic
‚îÇ           ‚îú‚îÄ‚îÄ create-generic.usecase.interface.ts
‚îÇ           ‚îú‚îÄ‚îÄ create-generic.usecase.ts
‚îÇ           ‚îú‚îÄ‚îÄ get-generic.usecase.interfaces.ts
‚îÇ           ‚îî‚îÄ‚îÄ get-generic.usecase.ts
‚îÇ
‚îú‚îÄ‚îÄ config
‚îÇ   ‚îî‚îÄ‚îÄ container.ts
‚îÇ
‚îú‚îÄ‚îÄ domain
‚îÇ   ‚îú‚îÄ‚îÄ entities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ generic.entity.ts
‚îÇ   ‚îî‚îÄ‚îÄ interfaces
‚îÇ       ‚îî‚îÄ‚îÄ service
‚îÇ           ‚îî‚îÄ‚îÄ health.service.interface.ts
‚îÇ
‚îú‚îÄ‚îÄ infraestructure
‚îÇ   ‚îú‚îÄ‚îÄ controllers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ health.controller.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ v1
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ generic.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ http
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ health.routes.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ v1
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ generic.routes.ts
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îî‚îÄ‚îÄ service
‚îÇ       ‚îî‚îÄ‚îÄ health.service.ts
‚îÇ
‚îú‚îÄ‚îÄ main.ts
‚îú‚îÄ‚îÄ server.ts
‚îî‚îÄ‚îÄ types
    ‚îî‚îÄ‚îÄ express.d.ts
```

---

# üß© 4. Inyecci√≥n de Dependencias ‚Äì Awilix

## Instalaci√≥n

```bash
npm install awilix awilix-express
```

## container.ts

```ts
import { createContainer, asClass, InjectionMode } from "awilix";

export const container = createContainer({
  injectionMode: InjectionMode.CLASSIC
});
```

## server.ts

```ts
app.use(scopePerRequest(container));
```

---

# üß™ 5. Testing con Vitest

## Instalaci√≥n

```bash
npm install -D vitest @vitest/coverage-v8 supertest
```

## vitest.config.ts

```ts
import { defaultExclude, defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    environment: "node",
    globals: true,
    include: ["test/**/*.spec.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "html", "lcov"],
      include: ["src/**/*.ts"],
      exclude: [
        ...defaultExclude,
        "**/*.spec.ts",
        "**/node_modules/**",
        "src/config/**",
        "test/**/*.spec.t",
        "**/infraestructure/controllers/**"
      ]
    }
  }
});

```

---

## Scripts en package.json

```json
"scripts": {
  "dev": "nodemon --exec ts-node --files src/main.ts",
  "build": "tsc",
  "start": "node dist/main.js",
  "test": "vitest",
  "test:run": "vitest run",
  "test:coverage": "vitest run --coverage"
}
```

---

# üöÄ 6. Instalaci√≥n del Proyecto

```bash
npm install
npm run dev
```

---

# üì° 7. Endpoints

```
GET    /api/v1/generic
POST   /api/v1/generic
PATCH  /api/v1/generic/:id
```

---

# üß† 8. Principios Aplicados

- Separation of Concerns
- Dependency Inversion
- Clean Architecture
- Single Responsibility
- Ports & Adapters
- Testabilidad

---

# üéì 9. Reglas del Proyecto

- El Domain no conoce infraestructura.
- El Use Case no conoce Express.
- El Controller no conoce el container.
- Las rutas solo conectan HTTP con Controller.
- Las entidades exponen `toPersistence()` para almacenamiento.

---

# üèÅ 10. Conclusi√≥n

Este chasis permite:

- Escalar a microservicios
- Cambiar base de datos sin tocar dominio
- Implementar eventos
- Probar l√≥gica sin levantar servidor
- Aplicar arquitectura limpia de forma profesional

---

> El dominio define el negocio.  
> La aplicaci√≥n ejecuta acciones.  
> La infraestructura implementa detalles.
